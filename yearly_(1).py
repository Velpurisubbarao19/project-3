# -*- coding: utf-8 -*-
"""Yearly (1).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1x-7lbD7lxqqAJGXRligtjrMwA-btx3Xl
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from prophet import Prophet
from sklearn.metrics import mean_absolute_error, mean_absolute_percentage_error, r2_score

# Load the yearly dataset
yearly_file_path = r"C:\Users\91970\Downloads\SN_y_tot_V2.0.csv"  # Update this with the correct path

# Read the dataset
yearly_data = pd.read_csv(yearly_file_path, delimiter=';', header=None)

# Inspect the first few rows and the shape of the DataFrame
print("First few rows of the dataset:")
print(yearly_data.head())
print("Shape of the dataset:", yearly_data.shape)

# Check how many columns are in the DataFrame
num_columns = yearly_data.shape[1]
print(f"Number of columns in the dataset: {num_columns}")

# Preprocess the yearly data
if num_columns >= 2:  # Check if there are at least 2 columns
    # Adjust this line based on the actual number of columns
    yearly_data.columns = ['Year', 'Mean Sunspot Number'] + [f'Extra_{i}' for i in range(num_columns - 2)]
else:
    raise ValueError("The dataset does not contain enough columns.")

# Check for valid years
yearly_data['Year'] = pd.to_numeric(yearly_data['Year'], errors='coerce')  # Convert to numeric, coercing errors
yearly_data = yearly_data[yearly_data['Year'].notna()]  # Remove rows with NaN in 'Year'
yearly_data = yearly_data[(yearly_data['Year'] >= 1900) & (yearly_data['Year'] <= 2100)]  # Keep reasonable year range

# Check if there are still valid entries after filtering
if yearly_data.empty:
    raise ValueError("No valid year entries found after filtering.")

# Convert 'Year' to datetime
yearly_data['Year'] = pd.to_datetime(yearly_data['Year'], format='%Y')

# Continue with preprocessing
yearly_data = yearly_data[yearly_data['Mean Sunspot Number'] >= 0]  # Remove invalid entries
yearly_data = yearly_data.rename(columns={'Year': 'ds', 'Mean Sunspot Number': 'y'})
yearly_data['y'] = yearly_data['y'].replace(0, 1e-6)  # Avoid log(0)
yearly_data['y'] = yearly_data['y'].apply(lambda x: np.log(x + 1e-6))  # Log transformation
yearly_data = yearly_data[yearly_data['y'] > 0]  # Keep only positive values

# Initialize and fit the Prophet model for yearly data
yearly_model = Prophet()
yearly_model.fit(yearly_data[['ds', 'y']])  # Fit only with the required columns

# Generate future dates and forecast for the next 20 years
future_yearly = yearly_model.make_future_dataframe(periods=20, freq='Y')
forecast_yearly = yearly_model.predict(future_yearly)

# Plot the forecast for yearly data
fig_yearly = yearly_model.plot(forecast_yearly)
plt.title("Yearly Sunspot Forecasting with Prophet")
plt.xlabel("Year")
plt.ylabel("Mean Sunspot Number (log-transformed)")
plt.show()

# Calculate metrics for the last available predictions if applicable
if len(yearly_data) >= 20:
    y_true_yearly = yearly_data['y'].tail(20)  # Adjust based on available data
    y_pred_yearly = forecast_yearly['yhat'][-20:]  # Corresponding predictions

    mae_yearly = mean_absolute_error(y_true_yearly, y_pred_yearly)
    mape_yearly = mean_absolute_percentage_error(y_true_yearly, y_pred_yearly)
    r2_yearly = r2_score(y_true_yearly, y_pred_yearly)

    # Corrected print statement
    print(f"Yearly Forecast Metrics: MAE: {mae_yearly:.4f}, MAPE: {mape_yearly:.4f}, RÂ²: {r2_yearly:.4f}")
else:
    print("Not enough data to calculate metrics.")

